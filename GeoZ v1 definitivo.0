import pygame
import random
import pickle
import sys
from datetime import datetime
import os

# ------------------------- ENTIDADES Y MEC√ÅNICAS -------------------------
class Recurso:
    def __init__(self, tipo: str, cantidad: int, posicion_x: int, posicion_y: int):
        self.tipo = tipo
        self.cantidad = cantidad
        self.posicion_x = posicion_x
        self.posicion_y = posicion_y


class Personaje:
    def __init__(self, vida: int, ataque: int, defensa: float, velocidad: float, categoria: str, habilidad: str,
                 estado: bool, posicion_x: int, posicion_y: int, con_vida: bool = True):
        self.vida = vida
        self.ataque = ataque
        self.defensa = defensa
        self.velocidad = velocidad
        self.categoria = categoria
        self.habilidad = habilidad
        self.estado = estado
        self.con_vida = con_vida
        self.posicion_x = posicion_x
        self.posicion_y = posicion_y
        self.efectos = {}
        self.inventario = []

    def mover_aleatorio(self, escenario):
        dx = random.choice([-1, 0, 1])
        dy = random.choice([-1, 0, 1])
        nuevo_x = self.posicion_x + dx
        nuevo_y = self.posicion_y + dy

        if 0 <= nuevo_x < escenario.ancho and 0 <= nuevo_y < escenario.alto:
            try:
                escenario.tablero[self.posicion_x][self.posicion_y].entidades.remove(self)
            except ValueError:
                pass
            self.posicion_x = nuevo_x
            self.posicion_y = nuevo_y
            escenario.tablero[nuevo_x][nuevo_y].entidades.append(self)

    def actuar(self, escenario):
        pass


# ------------------------- CIVILES -------------------------
class Civil(Personaje):
    def __init__(self, vida: int, ataque: int, defensa: float, velocidad: float, categoria: str, habilidad: str,
                 estado: bool, energia: int, posicion_x: int, posicion_y: int, con_vida: bool = True):
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, posicion_x, posicion_y,
                         con_vida)
        self.energia = energia
        self.turnos_infeccion = None

    def infectar(self):
        if not self.estado and self.con_vida:
            self.estado = True
            self.turnos_infeccion = 3

    def morir(self):
        self.con_vida = False
        self.estado = False
        self.turnos_infeccion = None

    def avanzar_turno(self):
        if self.estado and self.turnos_infeccion is not None:
            self.turnos_infeccion -= 1
            if self.turnos_infeccion <= 0:
                self.morir()

        for efecto in list(self.efectos.keys()):
            self.efectos[efecto] -= 1
            if self.efectos[efecto] <= 0:
                del self.efectos[efecto]


class Civil_Normal(Civil):
    def __init__(self, vida: int = 100, ataque: int = 5, defensa: float = None, velocidad: float = 2.5,
                 categoria: str = "Civil Normal", habilidad: str = "Sobrevivir", estado: bool = False,
                 energia: int = 50, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.1
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = []

    def actuar(self, escenario):
        if not self.con_vida:
            return
        self.mover_aleatorio(escenario)
        self.avanzar_turno()


class Atacante(Civil):
    def __init__(self, vida: int = 100, ataque: int = 40, defensa: float = None, velocidad: float = 5.0,
                 categoria: str = "Atacante", habilidad: str = "Esquivar", estado: bool = False,
                 energia: int = 100, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.2
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Espada"]

    def esquivar(self):
        self.efectos["esquivando"] = 5

    def mover_hacia_zombi(self, escenario):
        # comportamiento simple: moverse aleatoriamente
        self.mover_aleatorio(escenario)

    def atacar(self, escenario):
        x = self.posicion_x
        y = self.posicion_y
        celda = escenario.tablero[x][y]
        for entidad in list(celda.entidades):
            if isinstance(entidad, Zombie) and entidad.con_vida:
                da√±o = max(0, int(self.ataque - entidad.defensa))
                entidad.vida -= da√±o
                killed = False
                if entidad.vida <= 0:
                    entidad.con_vida = False
                    try:
                        celda.entidades.remove(entidad)
                    except ValueError:
                        pass
                    if entidad in escenario.personajes:
                        escenario.personajes.remove(entidad)
                    killed = True
                return (entidad.__class__.__name__, da√±o, killed, (x, y))
        return None

    def actuar(self, escenario):
        if not self.con_vida:
            return
        resultado = self.atacar(escenario)
        self.mover_hacia_zombi(escenario)
        self.avanzar_turno()
        return resultado


class Defensor(Civil):
    def __init__(self, vida: int = 100, ataque: int = 20, defensa: float = None, velocidad: float = 3.5,
                 categoria: str = "Defensor", habilidad: str = "Bloqueo", estado: bool = False,
                 energia: int = 100, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.5
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Escudo"]

    def bloquear(self):
        self.efectos["bloqueando"] = 8

    def mover_hacia_civil(self, escenario):
        self.mover_aleatorio(escenario)

    def proteger(self, civil: Civil):
        if civil.con_vida:
            civil.efectos["protegido"] = 3
            return civil
        return None

    def actuar(self, escenario):
        if not self.con_vida:
            return
        self.mover_hacia_civil(escenario)
        x, y = self.posicion_x, self.posicion_y
        celda = escenario.tablero[x][y]
        for entidad in celda.entidades:
            if isinstance(entidad, Civil) and entidad.con_vida and entidad != self:
                self.proteger(entidad)
                break
        self.avanzar_turno()


class Productor(Civil):
    def __init__(self, vida: int = 100, ataque: int = 5, defensa: float = None, velocidad: float = 4.0,
                 categoria: str = "Productor", habilidad: str = "Duplicar", estado: bool = False,
                 energia: int = 150, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.1
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Saco"]

    def recolectar(self, recurso: Recurso):
        if recurso.cantidad > 0:
            cantidad = 1
            if self.efectos.get("recolectando_doble", 0) > 0:
                cantidad *= 2
            cantidad_real = min(cantidad, recurso.cantidad)
            recurso.cantidad = max(0, recurso.cantidad - cantidad_real)
            self.inventario.append((recurso.tipo, cantidad_real))
            return (recurso.tipo, cantidad_real)
        return None

    def duplicar_recoleccion(self, recurso: Recurso):
        self.efectos["recolectando_doble"] = 3

    def mover_hacia_recurso(self, escenario):
        self.mover_aleatorio(escenario)

    def actuar(self, escenario):
        if not self.con_vida:
            return
        x, y = self.posicion_x, self.posicion_y
        celda = escenario.tablero[x][y]
        for entidad in celda.entidades:
            if isinstance(entidad, Recurso) and entidad.cantidad > 0:
                self.recolectar(entidad)
                break
        self.mover_hacia_recurso(escenario)
        self.avanzar_turno()


class Cientifico(Civil):
    def __init__(self, vida: int = 100, ataque: int = 5, defensa: float = None, velocidad: float = 4.0,
                 categoria: str = "Cient√≠fico", habilidad: str = "Reducci√≥n", estado: bool = False,
                 energia: int = 100, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.1
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Kit Cientifico"]

    def reducir_tiempo_espera(self, civiles: list):
        for civil in civiles:
            if isinstance(civil, Civil) and civil.con_vida and civil.estado and civil.turnos_infeccion is not None:
                civil.turnos_infeccion += 2

    def mover_hacia_infectados(self, escenario):
        self.mover_aleatorio(escenario)

    def actuar(self, escenario):
        if not self.con_vida:
            return
        x, y = self.posicion_x, self.posicion_y
        celda = escenario.tablero[x][y]
        civiles = [e for e in celda.entidades if isinstance(e, Civil) and e.estado and e.con_vida]
        if civiles:
            self.reducir_tiempo_espera(civiles)
        self.mover_hacia_infectados(escenario)
        self.avanzar_turno()


class Medico(Civil):
    def __init__(self, vida: int = 100, ataque: int = 5, defensa: float = None, velocidad: float = 3.0,
                 categoria: str = "M√©dico", habilidad: str = "Curaci√≥n", estado: bool = False,
                 energia: int = 150, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.1
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Vendas"]

    def curar(self, civil: Civil):
        if civil.estado and civil.con_vida:
            civil.estado = False
            civil.turnos_infeccion = None
            return civil
        return None

    def curar_en_celda(self, escenario):
        x = self.posicion_x
        y = self.posicion_y
        celda = escenario.tablero[x][y]

        for entidad in list(celda.entidades):
            if isinstance(entidad, Civil) and entidad.estado and entidad.con_vida:
                return self.curar(entidad)
        return None

    def mover_hacia_infectado(self, escenario):
        self.mover_aleatorio(escenario)

    def actuar(self, escenario):
        if not self.con_vida:
            return
        self.curar_en_celda(escenario)
        self.mover_hacia_infectado(escenario)
        self.avanzar_turno()


# ------------------------- ZOMBIES -------------------------
class Zombie(Personaje):
    def __init__(self, vida: int, ataque: int, defensa: float, velocidad: float, categoria: str, habilidad: str,
                 estado: bool, color: str, posicion_x: int, posicion_y: int, con_vida: bool = True):
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, posicion_x, posicion_y,
                         con_vida)
        self.color = color

    def mover_aleatorio(self, escenario):
        dx = random.choice([-1, 0, 1])
        dy = random.choice([-1, 0, 1])
        nuevo_x = self.posicion_x + dx
        nuevo_y = self.posicion_y + dy

        if 0 <= nuevo_x < escenario.ancho and 0 <= nuevo_y < escenario.alto:
            try:
                escenario.tablero[self.posicion_x][self.posicion_y].entidades.remove(self)
            except ValueError:
                pass
            self.posicion_x = nuevo_x
            self.posicion_y = nuevo_y
            escenario.tablero[nuevo_x][nuevo_y].entidades.append(self)


class Verde(Zombie):
    def __init__(self, posicion_x: int, posicion_y: int):
        super().__init__(vida=100, ataque=40, defensa=100 * 0.2, velocidad=3.5, categoria="Normal",
                         habilidad="Escupir", estado=True, color="Verde", posicion_x=posicion_x,
                         posicion_y=posicion_y, con_vida=True)

    def escupir(self, civil: Civil):
        if civil.con_vida and not civil.estado:
            civil.infectar()
            return civil
        return None


class Morado(Zombie):
    def __init__(self, posicion_x: int, posicion_y: int):
        super().__init__(vida=150, ataque=30, defensa=150 * 0.5, velocidad=2.0, categoria="Tanque",
                         habilidad="Aplastar", estado=True, color="Morado", posicion_x=posicion_x,
                         posicion_y=posicion_y, con_vida=True)

    def aplastar(self, civil: Civil):
        if civil.con_vida:
            civil.morir()
            return civil
        return None


class Amarillo(Zombie):
    def __init__(self, posicion_x: int, posicion_y: int):
        super().__init__(vida=80, ataque=50, defensa=80 * 0.1, velocidad=5.5, categoria="Veloz",
                         habilidad="Doble ataque", estado=True, color="Amarillo", posicion_x=posicion_x,
                         posicion_y=posicion_y, con_vida=True)

    def doble_atacar(self, escenario):
        x = self.posicion_x
        y = self.posicion_y
        infectados = []
        for entidad in list(escenario.tablero[x][y].entidades):
            if isinstance(entidad, Civil) and entidad.con_vida and not entidad.estado:
                entidad.infectar()
                infectados.append(entidad)
                if len(infectados) == 2:
                    break
        return infectados


# ------------------------- JUGADOR -------------------------
class Jugador(Civil):
    def __init__(self, vida: int = 100, ataque: int = 25, defensa: float = None, velocidad: float = 4.0,
                 categoria: str = "Jugador", habilidad: str = "Interactuar", estado: bool = False,
                 energia: int = 100, posicion_x: int = 0, posicion_y: int = 0, con_vida: bool = True):
        if defensa is None:
            defensa = vida * 0.3
        super().__init__(vida, ataque, defensa, velocidad, categoria, habilidad, estado, energia, posicion_x,
                         posicion_y, con_vida)
        self.inventario = ["Botiqu√≠n", "Mapa"]
        self.efectos["controlado_por_jugador"] = True

    def mover(self, direccion: str, escenario):
        dx = 0
        dy = 0
        if direccion == "W":
            dy = -1
        elif direccion == "S":
            dy = 1
        elif direccion == "A":
            dx = -1
        elif direccion == "D":
            dx = 1

        nuevo_x = self.posicion_x + dx
        nuevo_y = self.posicion_y + dy

        if 0 <= nuevo_x < escenario.ancho and 0 <= nuevo_y < escenario.alto:
            try:
                escenario.tablero[self.posicion_x][self.posicion_y].entidades.remove(self)
            except ValueError:
                pass
            self.posicion_x = nuevo_x
            self.posicion_y = nuevo_y
            escenario.tablero[nuevo_x][nuevo_y].entidades.append(self)

    def atacar_zombie(self, zombie: Zombie):
        if zombie.con_vida:
            da√±o = max(0, int(self.ataque - zombie.defensa))
            zombie.vida -= da√±o
            if zombie.vida <= 0:
                zombie.con_vida = False

    def interactuar(self, escenario):
        celda = escenario.tablero[self.posicion_x][self.posicion_y]
        acciones = []

        for entidad in list(celda.entidades):
            if isinstance(entidad, Zombie) and entidad.con_vida:
                self.atacar_zombie(entidad)
                acciones.append(f"Atacaste a un zombi {entidad.color}.")

        for entidad in list(celda.entidades):
            if isinstance(entidad, Civil) and entidad.estado and entidad.con_vida:
                self.curar(entidad)
                acciones.append("Curaste a un civil infectado.")

        for entidad in list(celda.entidades):
            if isinstance(entidad, Recurso) and entidad.cantidad > 0:
                resultado = self.recolectar(entidad)
                if resultado:
                    acciones.append(resultado)
                    if entidad.cantidad <= 0:
                        try:
                            celda.entidades.remove(entidad)
                        except ValueError:
                            pass
                break

        return ", ".join(acciones) if acciones else "Nada que hacer aqu√≠."

    def recolectar(self, recurso):
        if self.energia <= 0:
            return "Est√°s demasiado cansado para recolectar"

        self.inventario.append((recurso.tipo, 1))
        self.energia -= 1
        return f"Recolectaste {recurso.tipo}"

    def curar(self, civil: Civil):
        if civil.estado and civil.con_vida:
            civil.estado = False
            civil.turnos_infeccion = None


# ------------------------- ESCENARIO -------------------------
class Celda:
    def __init__(self, tipo: str, posicion_x: int, posicion_y: int):
        self.tipo = tipo
        self.posicion_x = posicion_x
        self.posicion_y = posicion_y
        self.entidades = []


class Escenario:
    def __init__(self, ancho: int, alto: int):
        self.ancho = ancho
        self.alto = alto
        self.tablero = [[Celda("campo", x, y) for y in range(alto)] for x in range(ancho)]
        self.recursos = []
        self.personajes = []

    def agregar_personaje(self, personaje):
        x = personaje.posicion_x
        y = personaje.posicion_y
        if 0 <= x < self.ancho and 0 <= y < self.alto:
            self.tablero[x][y].entidades.append(personaje)
            self.personajes.append(personaje)
        else:
            print(f"Posici√≥n fuera del tablero: ({x}, {y})")

    def definir_ciudad(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "ciudad"

    def definir_campo(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "campo"

    def crear_zombie_aleatorio(self, x: int, y: int):
        tipo = random.choice([Verde, Morado, Amarillo])
        return tipo(x, y)

    def definir_zona_zombie(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "zona_zombie"
                for _ in range(4):
                    zombi = self.crear_zombie_aleatorio(x, y)
                    self.tablero[x][y].entidades.append(zombi)
                    self.personajes.append(zombi)

    def definir_lago(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "lago"
                recurso = Recurso("agua", cantidad=50, posicion_x=x, posicion_y=y)
                self.tablero[x][y].entidades.append(recurso)
                self.recursos.append(recurso)

    def definir_rio(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "rio"
                recurso = Recurso("agua", cantidad=30, posicion_x=x, posicion_y=y)
                self.tablero[x][y].entidades.append(recurso)
                self.recursos.append(recurso)

    def definir_bosque(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "bosque"
                recurso = Recurso("madera", cantidad=40, posicion_x=x, posicion_y=y)
                self.tablero[x][y].entidades.append(recurso)
                self.recursos.append(recurso)

    def definir_mina(self, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for x in range(inicio_x, min(self.ancho, inicio_x + ancho)):
            for y in range(inicio_y, min(self.alto, inicio_y + alto)):
                self.tablero[x][y].tipo = "mina"
                recurso = Recurso("mineral", cantidad=30, posicion_x=x, posicion_y=y)
                self.tablero[x][y].entidades.append(recurso)
                self.recursos.append(recurso)

    def imprimir_tablero(self):
        simbolos = {"ciudad": "C", "campo": "F", "zona_zombie": "Z", "lago": "L", "rio": "R", "bosque": "B", "mina": "M"}

        for y in range(self.alto):
            fila = ""
            for x in range(self.ancho):
                tipo = self.tablero[x][y].tipo
                fila += simbolos.get(tipo, "?") + " "
            print(fila)

    def poblar_ciudad(self, cantidad_normales: int, cantidad_atacantes: int, cantidad_defensores: int,
                      cantidad_productores: int, cantidad_cientificos: int, cantidad_medicos: int,
                      inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for _ in range(cantidad_normales):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            civil = Civil_Normal(posicion_x=x, posicion_y=y)
            self.agregar_personaje(civil)

        for _ in range(cantidad_atacantes):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            atacante = Atacante(posicion_x=x, posicion_y=y)
            self.agregar_personaje(atacante)

        for _ in range(cantidad_defensores):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            defensor = Defensor(posicion_x=x, posicion_y=y)
            self.agregar_personaje(defensor)

        for _ in range(cantidad_productores):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            productor = Productor(posicion_x=x, posicion_y=y)
            self.agregar_personaje(productor)

        for _ in range(cantidad_cientificos):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            cientifico = Cientifico(posicion_x=x, posicion_y=y)
            self.agregar_personaje(cientifico)

        for _ in range(cantidad_medicos):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            medico = Medico(posicion_x=x, posicion_y=y)
            self.agregar_personaje(medico)

    def poblar_zona_zombie(self, cantidad_zombies: int, inicio_x: int, inicio_y: int, ancho: int, alto: int):
        for _ in range(cantidad_zombies):
            x = random.randint(inicio_x, min(inicio_x + ancho - 1, self.ancho - 1))
            y = random.randint(inicio_y, min(inicio_y + alto - 1, self.alto - 1))
            zombi = self.crear_zombie_aleatorio(x, y)
            self.agregar_personaje(zombi)

    def simular_turno(self):
        """Simula un turno y devuelve lista de eventos (categoria, mensaje)."""
        eventos = []

        # 1. Avance de estados internos
        for personaje in list(self.personajes):
            if isinstance(personaje, Civil):
                personaje.avanzar_turno()
                if not personaje.con_vida:
                    eventos.append(("General", f"{personaje.__class__.__name__} muri√≥ por infecci√≥n en ({personaje.posicion_x},{personaje.posicion_y})."))
                    try:
                        self.tablero[personaje.posicion_x][personaje.posicion_y].entidades.remove(personaje)
                    except Exception:
                        pass
                    if personaje in self.personajes:
                        self.personajes.remove(personaje)

        # 2. Movimiento y acciones
        for personaje in list(self.personajes):
            if not personaje.con_vida:
                continue

            # NO MOVER AL JUGADOR (solo controlado por el usuario)
            if isinstance(personaje, Jugador):
                continue

            # mover por tipo
            try:
                personaje.mover_aleatorio(self)
            except Exception:
                pass

            if isinstance(personaje, Medico):
                curado = personaje.curar_en_celda(self)
                if curado:
                    eventos.append(("Medicos", f"M√©dico cura a {curado.__class__.__name__} en ({personaje.posicion_x},{personaje.posicion_y})."))

            elif isinstance(personaje, Cientifico):
                x = personaje.posicion_x
                y = personaje.posicion_y
                cel = self.tablero[x][y]
                infectados = [e for e in cel.entidades if isinstance(e, Civil) and e.estado and e.con_vida]
                if infectados:
                    personaje.reducir_tiempo_espera(infectados)
                    eventos.append(("Cientificos", f"Cient√≠fico ayuda a {len(infectados)} infectado(s) en ({x},{y})."))

            elif isinstance(personaje, Productor):
                x = personaje.posicion_x
                y = personaje.posicion_y
                cel = self.tablero[x][y]
                for ent in list(cel.entidades):
                    if isinstance(ent, Recurso) and ent.cantidad > 0:
                        res = personaje.recolectar(ent)
                        if res:
                            eventos.append(("Productores", f"Productor en ({x},{y}) recolecta {res[1]}x {res[0]}."))
                        break

            elif isinstance(personaje, Atacante):
                resultado = personaje.atacar(self)
                if resultado:
                    tipo, da√±o, killed, pos = resultado
                    eventos.append(("Atacantes", f"Atacante en ({pos[0]},{pos[1]}) ataca {tipo} (-{da√±o} vida)."))
                    if killed:
                        eventos.append(("Atacantes", f"Atacante mata a {tipo} en ({pos[0]},{pos[1]})."))

            elif isinstance(personaje, Defensor):
                x = personaje.posicion_x
                y = personaje.posicion_y
                cel = self.tablero[x][y]
                for entidad in cel.entidades:
                    if isinstance(entidad, Civil) and entidad.con_vida and entidad is not personaje:
                        protegido = personaje.proteger(entidad)
                        if protegido:
                            eventos.append(("Defensores", f"Defensor protege a {entidad.__class__.__name__} en ({x},{y})."))
                        break

            elif isinstance(personaje, Verde):
                x = personaje.posicion_x
                y = personaje.posicion_y
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        if dx == 0 and dy == 0:
                            continue
                        nx = x + dx
                        ny = y + dy
                        if 0 <= nx < self.ancho and 0 <= ny < self.alto:
                            celda = self.tablero[nx][ny]
                            for entidad in list(celda.entidades):
                                if isinstance(entidad, Civil) and entidad.con_vida and not entidad.estado:
                                    infectado = personaje.escupir(entidad)
                                    if infectado:
                                        eventos.append(("Zombie_Verde", f"Zombi Verde infecta a {infectado.__class__.__name__} en ({nx},{ny})."))
                                    break

            elif isinstance(personaje, Morado):
                x = personaje.posicion_x
                y = personaje.posicion_y
                cel = self.tablero[x][y]
                for entidad in list(cel.entidades):
                    if isinstance(entidad, Civil) and entidad.con_vida:
                        muerto = personaje.aplastar(entidad)
                        if muerto:
                            eventos.append(("Zombie_Morado", f"Zombi Morado aplasta a {muerto.__class__.__name__} en ({x},{y})."))
                            try:
                                cel.entidades.remove(muerto)
                            except ValueError:
                                pass
                            if muerto in self.personajes:
                                self.personajes.remove(muerto)
                        break

            elif isinstance(personaje, Amarillo):
                infectados = personaje.doble_atacar(self)
                if infectados:
                    x = personaje.posicion_x
                    y = personaje.posicion_y
                    eventos.append(("Zombie_Amarillo", f"Zombi Amarillo infecta {len(infectados)} civil(es) en ({x},{y})."))

        return eventos


# ------------------------- PERSISTENCIA Y CONTROLADOR (ahora con 3 slots) -------------------------
class Persistencia:
    def __init__(self, carpeta_saves: str = "saves"):
        # usar ruta absoluta para evitar problemas de CWD
        self.carpeta = os.path.abspath(carpeta_saves)
        os.makedirs(self.carpeta, exist_ok=True)
        self.index_file = os.path.join(self.carpeta, "saves_index.pkl")
        self.max_slots = 3
        if not os.path.exists(self.index_file):
            # crear √≠ndice vac√≠o
            index = [None] * self.max_slots
            with open(self.index_file, "wb") as f:
                pickle.dump(index, f)

    def _leer_index(self):
        try:
            with open(self.index_file, "rb") as f:
                return pickle.load(f)
        except Exception as e:
            print(f"[Persistencia] _leer_index fallo: {e}")
            return [None] * self.max_slots

    def _escribir_index(self, index):
        try:
            with open(self.index_file, "wb") as f:
                pickle.dump(index, f)
        except Exception as e:
            print(f"[Persistencia] _escribir_index fallo: {e}")

    def nombre_slot(self, slot: int):
        # devolver ruta ABSOLUTA dentro de la carpeta de saves
        return os.path.join(self.carpeta, f"save_slot{slot + 1}.cc")

    def guarda_slot(self, slot: int, escenario, jugador, ciclo:int=0, config:dict=None):
        """Guarda en el slot (0..max_slots-1)."""
        try:
            datos = {'escenario': escenario, 'jugador': jugador}
            nombre = os.path.abspath(self.nombre_slot(slot))

            # Backup autom√°tico
            if os.path.exists(nombre):
                backup = nombre + ".bak"
                try:
                    with open(nombre, "rb") as src, open(backup, "wb") as dst:
                        dst.write(src.read())
                except Exception as e:
                    print(f"[Persistencia] backup fallo: {e}")

            # Guardado seguro con temporal
            tmp = nombre + ".tmp"
            with open(tmp, "wb") as fos:
                pickle.dump(datos, fos)
            os.replace(tmp, nombre)

            # Metadatos enriquecidos
            try:
                total_entidades = sum(len(c.entidades) for fila in escenario.tablero for c in fila)
            except Exception:
                total_entidades = 0
            estado_general = "Estable" if getattr(jugador, "con_vida", True) else "Colapso"

            index = self._leer_index()
            index[slot] = {
                'nombre_archivo': nombre,
                'fecha': datetime.now().isoformat(),
                'version': "1",
                'ciclo': ciclo,
                'config': config or {},
                'total_entidades': total_entidades,
                'estado': estado_general
            }

            self._escribir_index(index)
            print(f"[Persistencia] guardado OK en slot {slot+1}: {nombre}")
            return True
        except Exception as e:
            print(f"[Persistencia] Error al guardar en slot {slot+1}: {e}")
            return False

    def rescatar_slot(self, slot: int):
        """Devuelve (escenario, jugador) o (None, None) si no existe."""
        index = self._leer_index()
        if slot < 0 or slot >= self.max_slots:
            print(f"[Persistencia] rescatar_slot: slot fuera de rango {slot}")
            return None, None
        meta = index[slot]
        if not meta:
            print(f"[Persistencia] rescatar_slot: slot {slot+1} vac√≠o")
            return None, None
        nombre = meta.get('nombre_archivo')
        if not nombre:
            print(f"[Persistencia] rescatar_slot: meta sin 'nombre_archivo' en slot {slot+1}")
            return None, None
        if not os.path.exists(nombre):
            print(f"[Persistencia] archivo de slot {slot+1} no encontrado: {nombre}")
            return None, None
        try:
            with open(nombre, 'rb') as fis:
                datos = pickle.load(fis)
                print(f"[Persistencia] rescatar_slot OK slot {slot+1}: {nombre}")
                return datos.get('escenario'), datos.get('jugador')
        except Exception as e:
            print(f"[Persistencia] Error al rescatar slot {slot+1}: {e}")
            return None, None

    def listar_slots(self):
        """Devuelve lista de metadatos (None o dict con filename/fecha) y a√±ade _existe_en_disco."""
        index = self._leer_index()
        for i, meta in enumerate(index):
            if meta and isinstance(meta, dict):
                ruta = meta.get('nombre_archivo')
                meta['_existe_en_disco'] = bool(ruta and os.path.exists(ruta))
        return index

    def borrar_slot(self, slot: int):
        index = self._leer_index()
        if 0 <= slot < self.max_slots and index[slot]:
            archivo = index[slot].get('nombre_archivo')
            try:
                if archivo and os.path.exists(archivo):
                    os.remove(archivo)
            except Exception as e:
                print(f"[Persistencia] borrar_slot error al borrar archivo: {e}")
            index[slot] = None
            self._escribir_index(index)
            return True
        return False

    def limpiar_temporales(self):
        """Elimina archivos temporales .tmp en la carpeta de saves."""
        try:
            for archivo in os.listdir(self.carpeta):
                if archivo.endswith(".tmp"):
                    try:
                        os.remove(os.path.join(self.carpeta, archivo))
                    except Exception:
                        pass
        except Exception as e:
            print(f"[Persistencia] limpiar_temporales fallo: {e}")

class Controlador:
    def __init__(self):
        self.persistencia = Persistencia()
        self.ultimo_guardado = False
        # √≠ndice rotativo para guardado autom√°tico
        self._next_slot = 0
        self.ciclo = 0
        self.autoguardado_n = 30
    
    def avanzar_turno(self, escenario, jugador):
        self.ciclo += 1
        eventos = escenario.simular_turno()
        # Autoguardado no intrusivo
        if self.autoguardado_n and self.ciclo % self.autoguardado_n == 0:
            ok, slot = self.guardar_partida_auto(escenario, jugador)
            if ok:
                print(f"[Autoguardado en slot {slot+1}]")
        return eventos


    def guardar_partida_auto(self, escenario, jugador):
        """Guarda en el primer slot vac√≠o; si todos llenos, sobrescribe en rotaci√≥n."""
        index = self.persistencia.listar_slots()
        # buscar primer None
        try:
            slot_libre = index.index(None)
        except ValueError:
            slot_libre = None
        if slot_libre is None:
            slot = self._next_slot % self.persistencia.max_slots
            self._next_slot = (self._next_slot + 1) % self.persistencia.max_slots
        else:
            slot = slot_libre
        ok = self.persistencia.guarda_slot(slot, escenario, jugador,  ciclo=self.ciclo)
        self.ultimo_guardado = ok
        return ok, slot

    def guardar_partida_en_slot(self, slot, escenario, jugador):
        ok = self.persistencia.guarda_slot(slot, escenario, jugador, ciclo=self.ciclo)
        self.ultimo_guardado = ok
        return ok

    def rescatar_slot(self, slot):
        return self.persistencia.rescatar_slot(slot)

    def listar_saves(self):
        return self.persistencia.listar_slots()


    def configurar_autoguardado(self, n:int):
        self.autoguardado_n = n


# ------------------------- VISTA (Pygame) -------------------------
class Vista:
    def __init__(self, escenario: Escenario, jugador: Jugador, ancho_ventana: int = 800, alto_ventana: int = 600):
        pygame.init()
        self.jugador = jugador
        self.escenario = escenario
        self.ancho_ventana = ancho_ventana
        self.barra_ancho = 300
        self.controlador = Controlador()

        info = pygame.display.Info()
        pantalla_alto = info.current_h
        margen = 50
        celda_alto = max(8, min(24, (pantalla_alto - margen) // max(1, self.escenario.alto)))
        self.alto_ventana = celda_alto * self.escenario.alto

        # limitar ancho para que quepa la barra lateral
        self.ventana_ancho_total = self.ancho_ventana
        self.ventana = pygame.display.set_mode((self.ventana_ancho_total, self.alto_ventana))
        pygame.display.set_caption("GeoZ4 - Simulaci√≥n de Supervivencia Zombie")
        self.reloj = pygame.time.Clock()

        self.mensajes = []
        self.sidebar_scroll = 0
        self.sidebar_line_h = 22
        self.sidebar_scroll_speed = 3

        self.celda_ancho = (self.ventana_ancho_total - self.barra_ancho) // max(1, self.escenario.ancho)
        self.celda_alto = self.alto_ventana // max(1, self.escenario.alto)

        self.correr_simulacion()

    def ejecutar_turno(self):
        eventos = self.escenario.simular_turno()
        for categoria, mensaje in eventos:
            self.mensajes.append(mensaje)
        while len(self.mensajes) > 50:
            self.mensajes.pop(0)

    def correr_simulacion(self):
        corriendo = True
        contador_turnos = 0

        while corriendo:
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    corriendo = False
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_ESCAPE:
                        # Volver al men√∫ principal
                        corriendo = False
                        pygame.quit()
                        
                        # Reiniciar pygame para el men√∫
                        pygame.init()
                        opcion, opcion_slot = menu_inicial(self.controlador)
                        
                        # Cargar seg√∫n la opci√≥n del men√∫
                        escenario = None
                        jugador = None
                        
                        if opcion == 'l':
                            index = self.controlador.listar_saves()
                            most_recent = None
                            recent_slot = None
                            for i, meta in enumerate(index):
                                if meta and meta.get('fecha'):
                                    if most_recent is None or meta['fecha'] > most_recent:
                                        most_recent = meta['fecha']
                                        recent_slot = i
                            if recent_slot is not None:
                                esc, jug = self.controlador.rescatar_slot(recent_slot)
                                if esc is not None and jug is not None:
                                    escenario = esc
                                    jugador = jug
                        
                        elif opcion == 'l_slot' and opcion_slot is not None:
                            esc, jug = self.controlador.rescatar_slot(opcion_slot)
                            if esc is not None and jug is not None:
                                escenario = esc
                                jugador = jug
                        
                        if escenario is None:
                            escenario = crear_escenario_predeterminado()
                        
                        if jugador is None:
                            jugador = Jugador(posicion_x=24, posicion_y=24)
                            escenario.agregar_personaje(jugador)
                        else:
                            if jugador not in escenario.personajes:
                                escenario.agregar_personaje(jugador)
                        
                        # Reiniciar Vista
                        vista = Vista(escenario, jugador)
                        return
                    
                    elif evento.key == pygame.K_w:
                        self.jugador.mover("W", self.escenario)
                    elif evento.key == pygame.K_s:
                        self.jugador.mover("S", self.escenario)
                    elif evento.key == pygame.K_a:
                        self.jugador.mover("A", self.escenario)
                    elif evento.key == pygame.K_d:
                        self.jugador.mover("D", self.escenario)
                    elif evento.key == pygame.K_e:
                        resultado = self.jugador.interactuar(self.escenario)
                        if resultado:
                            self.mensajes.append(resultado)
                    elif evento.key == pygame.K_g:
                        # abrir submen√∫ para elegir slot (1-3)
                        try:
                            slot, ok = menu_guardar_en_slot(self.controlador, self.escenario, self.jugador)
                        except Exception as e:
                            slot, ok = None, False
                            print(f"[Vista] Error al abrir menu_guardar_en_slot: {e}")

                        if slot is None:
                            self.mensajes.append("Guardado cancelado.")
                        else:
                            if ok:
                                self.mensajes.append(f"üéâ Partida guardada en slot {slot + 1}.")
                                self.controlador.ultimo_guardado = True
                            else:
                                self.mensajes.append("‚ùå Error al guardar la partida.")

                    elif evento.key == pygame.K_DELETE:
                        # Abrir submen√∫ para elegir slot a BORRAR
                        try:
                            slot = menu_borrar_slot(self.controlador)
                            if slot is not None:
                                self.controlador.persistencia.borrar_slot(slot)
                                self.mensajes.append(f"üóëÔ∏è Slot {slot + 1} borrado.")
                        except Exception as e:
                            print(f"[Vista] Error al borrar slot: {e}")

                elif evento.type == pygame.MOUSEWHEEL:
                    delta_px = -evento.y * self.sidebar_line_h * self.sidebar_scroll_speed
                    self.sidebar_scroll += delta_px

            # actualizar pantalla
            self.ventana.fill((0, 0, 0))
            self.dibujar_escenario()
            self.dibujar_barra_lateral()

            pygame.display.flip()

            contador_turnos += 1
            if contador_turnos >= 12:  # cada N frames ejecuta turno
                self.ejecutar_turno()
                contador_turnos = 0

            if not self.jugador.con_vida:
                if not any("ha muerto" in m.lower() for m in self.mensajes):
                    self.mensajes.append("El jugador ha muerto. Fin de la simulaci√≥n.")
                pygame.time.delay(2000)
                corriendo = False
                break

            self.reloj.tick(30)

        pygame.quit()

    def dibujar_escenario(self):
        # recalcular tama√±os por si cambi√≥ la ventana
        self.celda_ancho = (self.ventana_ancho_total - self.barra_ancho) // max(1, self.escenario.ancho)
        self.celda_alto = self.alto_ventana // max(1, self.escenario.alto)

        for x in range(self.escenario.ancho):
            for y in range(self.escenario.alto):
                celda = self.escenario.tablero[x][y]
                color_celda = (34, 139, 34)

                if celda.tipo == "ciudad":
                    color_celda = (169, 169, 169)
                elif celda.tipo == "zona_zombie":
                    color_celda = (80, 0, 0)
                elif celda.tipo == "campo":
                    color_celda = (34, 139, 34)
                elif celda.tipo == "lago":
                    color_celda = (0, 191, 255)
                elif celda.tipo == "rio":
                    color_celda = (30, 144, 255)
                elif celda.tipo == "bosque":
                    color_celda = (0, 100, 0)
                elif celda.tipo == "mina":
                    color_celda = (139, 69, 19)

                rect_x = x * self.celda_ancho
                rect_y = y * self.celda_alto
                pygame.draw.rect(self.ventana, color_celda, (rect_x, rect_y, self.celda_ancho, self.celda_alto))

                for entidad in celda.entidades:
                    if entidad is self.jugador:
                        color_entidad = (0, 0, 0)
                    elif isinstance(entidad, Civil_Normal):
                        color_entidad = (0, 0, 255)
                    elif isinstance(entidad, Atacante):
                        color_entidad = (0, 255, 255)
                    elif isinstance(entidad, Defensor):
                        color_entidad = (255, 165, 0)
                    elif isinstance(entidad, Productor):
                        color_entidad = (255, 192, 203)
                    elif isinstance(entidad, Cientifico):
                        color_entidad = (75, 0, 150)
                    elif isinstance(entidad, Medico):
                        color_entidad = (0, 255, 0)
                    elif isinstance(entidad, Verde):
                        color_entidad = (34, 119, 34)
                    elif isinstance(entidad, Morado):
                        color_entidad = (128, 0, 128)
                    elif isinstance(entidad, Amarillo):
                        color_entidad = (255, 255, 0)
                    elif isinstance(entidad, Recurso):
                        color_entidad = (200, 200, 200)
                    else:
                        continue

                    cx = rect_x + self.celda_ancho // 2
                    cy = rect_y + self.celda_alto // 2
                    radius = max(2, min(self.celda_ancho, self.celda_alto) // 4)
                    pygame.draw.circle(self.ventana, color_entidad, (cx, cy), radius)

    def dibujar_barra_lateral(self):
        fuente = pygame.font.SysFont(None, 20)
        x_base = self.ventana_ancho_total - self.barra_ancho + 10

        pygame.draw.rect(self.ventana, (30, 30, 30), (self.ventana_ancho_total - self.barra_ancho, 0, self.barra_ancho, self.alto_ventana))

        lines = []
        lines.append("üßç JUGADOR")
        lines.append(" ----------CONTROLES---------- ")
        lines.append("W = Arriba, A = Izquierda")
        lines.append("S = Abajo, D = Derecha")
        lines.append("E: Interactuar, G: Guardar partida")
        lines.append(" ---------------------------- ")
        lines.append(f"Vida: {self.jugador.vida}")
        lines.append(f"Energ√≠a: {self.jugador.energia}")
        lines.append(f"Infectado: {'S√≠' if self.jugador.estado else 'No'}")
        lines.append(f"Posici√≥n: ({self.jugador.posicion_x}, {self.jugador.posicion_y})")
        lines.append(f"Guardado: {'S√≠' if self.controlador.ultimo_guardado else 'No'}")
        lines.append("Inventario:")
        for item in self.jugador.inventario:
            lines.append(f" - {item}")
        lines.append("")
        lines.append("√öltimas acciones:")
        for mensaje in reversed(self.mensajes[-20:]):
            lines.append(f"‚Ä¢ {mensaje}")

        total_lines = len(lines)
        total_height = total_lines * self.sidebar_line_h
        visible_height = self.alto_ventana
        max_scroll_px = max(0, total_height - visible_height)

        if self.sidebar_scroll < 0:
            self.sidebar_scroll = 0
        if self.sidebar_scroll > max_scroll_px:
            self.sidebar_scroll = max_scroll_px

        start_line = int(self.sidebar_scroll // self.sidebar_line_h)
        y_offset_px = -(self.sidebar_scroll % self.sidebar_line_h)

        y = y_offset_px + 10
        max_visible_lines = visible_height // self.sidebar_line_h + 2
        end_line = min(total_lines, start_line + max_visible_lines)

        for idx in range(start_line, end_line):
            text = lines[idx]
            color = (200, 200, 100) if text.startswith("‚Ä¢") else (255, 255, 255)
            render = fuente.render(text, True, color)
            self.ventana.blit(render, (x_base, y))
            y += self.sidebar_line_h

        if total_height > visible_height:
            bar_w = 8
            bar_x = self.ventana_ancho_total - 14
            bar_y = 4
            bar_h = visible_height - 8
            pygame.draw.rect(self.ventana, (60, 60, 60), (bar_x, bar_y, bar_w, bar_h))

            handle_h = max(20, int(bar_h * (visible_height / total_height)))
            if max_scroll_px > 0:
                handle_y = bar_y + int((bar_h - handle_h) * (self.sidebar_scroll / max_scroll_px))
            else:
                handle_y = bar_y
            pygame.draw.rect(self.ventana, (160, 160, 160), (bar_x, handle_y, bar_w, handle_h))


# ------------------------- MENU INICIAL Y CONFIGURACI√ìN (con P: Partidas guardadas) -------------------------
def crear_escenario_predeterminado():
    escenario = Escenario(50, 50)

    escenario.definir_ciudad(17, 17, 16, 16)

    escenario.definir_zona_zombie(0, 0, 5, 5)
    escenario.definir_zona_zombie(45, 0, 5, 5)
    escenario.definir_zona_zombie(0, 45, 5, 5)
    escenario.definir_zona_zombie(45, 45, 5, 5)

    escenario.definir_lago(20, 40, 5, 5)
    escenario.definir_lago(5, 5, 6, 6)
    escenario.definir_lago(44, 15, 4, 4)

    escenario.definir_rio(7, 14, 30, 2)
    escenario.definir_rio(33, 33, 2, 10)
    escenario.definir_bosque(5, 20, 8, 8)
    escenario.definir_bosque(35, 5, 10, 10)

    escenario.poblar_ciudad(
        cantidad_normales=10,
        cantidad_atacantes=5,
        cantidad_defensores=3,
        cantidad_productores=4,
        cantidad_cientificos=2,
        cantidad_medicos=3,
        inicio_x=17, inicio_y=17, ancho=16, alto=16
    )

    return escenario


def menu_partidas_guardadas(controlador: Controlador):
    """Muestra un men√∫ con los 3 slots. Devuelve el slot seleccionado (0..2) o None si vuelve.
       Tambi√©n permite borrar slots con DELETE+n√∫mero.
    """
    ancho = 600
    alto = 350
    pantalla = pygame.display.set_mode((ancho, alto))
    pygame.display.set_caption("GeoZ4 - Partidas guardadas")
    fuente = pygame.font.SysFont(None, 28)
    fuente_peq = pygame.font.SysFont(None, 20)
    clock = pygame.time.Clock()

    index = controlador.listar_saves()
    seleccion = None
    info_msg = ""
    delete_mode = False  # flag para saber si est√° en modo borrado

    while seleccion is None:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_DELETE:
                    # Activar modo borrado
                    delete_mode = True
                    info_msg = "Presiona 1, 2 o 3 para BORRAR ese slot (o ESC para cancelar)."
                elif evento.key in [pygame.K_1, pygame.K_2, pygame.K_3]:
                    slot_num = [pygame.K_1, pygame.K_2, pygame.K_3].index(evento.key)
                    if delete_mode:
                        # Borrar el slot
                        controlador.persistencia.borrar_slot(slot_num)
                        info_msg = f"Slot {slot_num + 1} borrado."
                        delete_mode = False
                        # Recargar √≠ndice
                        index = controlador.listar_saves()
                    else:
                        # Cargar el slot
                        seleccion = slot_num
                elif evento.key == pygame.K_ESCAPE:
                    if delete_mode:
                        delete_mode = False
                        info_msg = ""
                    else:
                        return None

        pantalla.fill((10, 10, 10))
        pantalla.blit(fuente.render("Partidas guardadas", True, (255, 255, 255)), (20, 20))
        
        if delete_mode:
            pantalla.blit(fuente_peq.render("MODO BORRADO ACTIVO - Presiona 1,2,3 para borrar | ESC para cancelar", True, (255, 100, 100)), (20, 50))
        else:
            pantalla.blit(fuente_peq.render("Presiona 1,2,3 para cargar | Tecla Supr para borrar | ESC para volver", True, (200, 200, 200)), (20, 50))
        
        for i in range(3):
            y = 100 + i * 70
            meta = index[i] if index and i < len(index) else None
            if meta:
                fecha = meta.get('fecha', 'sin fecha')
                ciclo = meta.get('ciclo', '?')
                total = meta.get('total_entidades', '?')
                estado = meta.get('estado', '?')

                texto = f"{i+1}) Slot {i+1} - Ciclo {ciclo}, Entidades {total}, Estado {estado}"
                pantalla.blit(fuente.render(texto, True, (200, 200, 200)), (40, y))
                pantalla.blit(fuente_peq.render(f"   Fecha: {fecha}", True, (160, 160, 160)), (40, y+25))
                pantalla.blit(fuente_peq.render(f"   Presiona {i+1} para cargar | Supr+{i+1} para borrar", True, (150, 150, 100)), (40, y+45))
            else:
                pantalla.blit(fuente.render(f"{i+1}) Slot {i+1} - Vac√≠o", True, (150, 150, 150)), (40, y))

        if info_msg:
            color_msg = (255, 100, 100) if delete_mode else (100, 200, 100)
            pantalla.blit(fuente_peq.render(info_msg, True, color_msg), (20, alto - 40))

        pygame.display.flip()
        clock.tick(30)

    return seleccion


def menu_guardar_en_slot(controlador: Controlador, escenario: Escenario, jugador: Jugador):
    """Muestra un submen√∫ para elegir slot (1-3). Devuelve (slot, ok) o (None, False) si se cancela."""
    ancho = 480
    alto = 220

    # guardar tama√±o actual de la ventana para restaurar despu√©s
    superficie_actual = pygame.display.get_surface()
    prev_size = superficie_actual.get_size() if superficie_actual else (800, 600)

    pantalla = pygame.display.set_mode((ancho, alto))
    pygame.display.set_caption("GeoZ4 - Guardar en slot")
    fuente = pygame.font.SysFont(None, 24)
    clock = pygame.time.Clock()

    index = controlador.listar_saves()
    seleccion = None

    info_msg = "Presiona 1,2 o 3 para guardar en ese slot. ESC para cancelar."

    while seleccion is None:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                # restaurar tama√±o antes de salir por completo
                try:
                    pygame.display.set_mode(prev_size)
                except Exception:
                    pass
                pygame.quit()
                sys.exit()
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_1:
                    seleccion = 0
                elif evento.key == pygame.K_2:
                    seleccion = 1
                elif evento.key == pygame.K_3:
                    seleccion = 2
                elif evento.key == pygame.K_ESCAPE:
                    try:
                        pygame.display.set_mode(prev_size)
                    except Exception:
                        pass
                    return None, False

        pantalla.fill((12, 12, 12))
        pantalla.blit(fuente.render("Guardar partida - Elige slot (1-3)", True, (255, 255, 255)), (18, 16))
        pantalla.blit(fuente.render(info_msg, True, (200, 200, 200)), (18, 44))

        for i in range(3):
            y = 84 + i * 44
            meta = index[i] if index and i < len(index) else None
            if meta:
                fecha = meta.get('fecha', 'sin fecha')
                estado = meta.get('estado', '?')
                existe = meta.get('_existe_en_disco', None)
                estado_fisico = "OK" if existe else "No existe"
                texto = f"{i+1}) Slot {i+1} - {estado}, {fecha} [{estado_fisico}]"
            else:
                texto = f"{i+1}) Slot {i+1} - Vac√≠o"
            pantalla.blit(fuente.render(texto, True, (220, 220, 180)), (34, y))

        pygame.display.flip()
        clock.tick(30)

    # realizar guardado en el slot seleccionado usando el controlador
    ok = controlador.guardar_partida_en_slot(seleccion, escenario, jugador)

    # restaurar tama√±o de ventana original antes de regresar al juego
    try:
        pygame.display.set_mode(prev_size)
    except Exception:
        pass

    return seleccion, ok

def menu_borrar_slot(controlador: Controlador):
    """Men√∫ para elegir slot a borrar. Devuelve slot (0..2) o None si cancela."""
    ancho = 480
    alto = 220

    superficie_actual = pygame.display.get_surface()
    prev_size = superficie_actual.get_size() if superficie_actual else (800, 600)

    pantalla = pygame.display.set_mode((ancho, alto))
    pygame.display.set_caption("GeoZ4 - Borrar slot")
    fuente = pygame.font.SysFont(None, 24)
    clock = pygame.time.Clock()

    index = controlador.listar_saves()
    seleccion = None
    info_msg = "Presiona 1,2 o 3 para BORRAR ese slot. ESC para cancelar."

    while seleccion is None:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                try:
                    pygame.display.set_mode(prev_size)
                except Exception:
                    pass
                pygame.quit()
                sys.exit()
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_1:
                    seleccion = 0
                elif evento.key == pygame.K_2:
                    seleccion = 1
                elif evento.key == pygame.K_3:
                    seleccion = 2
                elif evento.key == pygame.K_ESCAPE:
                    try:
                        pygame.display.set_mode(prev_size)
                    except Exception:
                        pass
                    return None

        pantalla.fill((12, 12, 12))
        pantalla.blit(fuente.render("BORRAR slot - Elige cu√°l (1-3)", True, (255, 100, 100)), (18, 16))
        pantalla.blit(fuente.render(info_msg, True, (200, 100, 100)), (18, 44))

        for i in range(3):
            y = 84 + i * 44
            meta = index[i] if index and i < len(index) else None
            if meta:
                fecha = meta.get('fecha', 'sin fecha')
                estado = meta.get('estado', '?')
                existe = meta.get('_existe_en_disco', None)
                estado_fisico = "OK" if existe else "No existe"
                texto = f"{i+1}) Slot {i+1} - {estado}, {fecha} [{estado_fisico}]"
            else:
                texto = f"{i+1}) Slot {i+1} - Vac√≠o"
            pantalla.blit(fuente.render(texto, True, (220, 220, 180)), (34, y))

        pygame.display.flip()
        clock.tick(30)

    try:
        pygame.display.set_mode(prev_size)
    except Exception:
        pass

    return seleccion

def menu_inicial(controlador: Controlador):
    """Men√∫ inicial: N - nueva partida, L - cargar √∫ltimo, P - partidas guardadas, Q/ESC - salir.
       Devuelve (opcion, opcion_slot) donde opcion es:
         - 'n'     -> nueva partida
         - 'l'     -> cargar √∫ltimo guardado
         - 'l_slot'-> cargar slot concreto, opcion_slot = √≠ndice 0..2
    """
    # Asegurar que pygame (y el subsistema de fuentes) est√©n inicializados
    if not pygame.get_init():
        pygame.init()
    if not pygame.font.get_init():
        pygame.font.init()

    ancho, alto = 700, 360

    # ahora s√≠ podemos leer la superficie actual (si existe) para restaurar tama√±o luego
    superficie_actual = pygame.display.get_surface()
    prev_size = superficie_actual.get_size() if superficie_actual else (800, 600)

    pantalla = pygame.display.set_mode((ancho, alto))
    pygame.display.set_caption("GeoZ4 - Men√∫ principal")
    fuente_tit = pygame.font.SysFont(None, 36)
    fuente = pygame.font.SysFont(None, 24)
    clock = pygame.time.Clock()

    instrucciones = [
        "N - Nueva partida",
        "L - Cargar √∫ltimo guardado",
        "P - Partidas guardadas (seleccionar slot)",
        "Q o ESC - Salir"
    ]

    while True:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_n:
                    try:
                        pygame.display.set_mode(prev_size)
                    except Exception:
                        pass
                    return 'n', None
                if evento.key == pygame.K_l:
                    try:
                        pygame.display.set_mode(prev_size)
                    except Exception:
                        pass
                    return 'l', None
                if evento.key == pygame.K_p:
                    # abrir el men√∫ de partidas guardadas; devuelve slot o None
                    slot = menu_partidas_guardadas(controlador)
                    try:
                        pygame.display.set_mode(prev_size)
                    except Exception:
                        pass
                    if slot is not None:
                        return 'l_slot', slot
                    # si cancel√≥, permanecer en men√∫ principal
                if evento.key == pygame.K_q or evento.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()

        pantalla.fill((8, 8, 8))
        pantalla.blit(fuente_tit.render("GeoZ4 - Men√∫ principal", True, (240, 240, 240)), (20, 18))
        pantalla.blit(fuente.render("Selecciona una opci√≥n:", True, (200, 200, 200)), (22, 70))

        y = 110
        for linea in instrucciones:
            pantalla.blit(fuente.render(linea, True, (220, 220, 180)), (36, y))
            y += 36

        # mostrar resumen de saves (debug friendly)
        saves = controlador.listar_saves()
        pantalla.blit(fuente.render("Partidas (slots):", True, (200, 200, 200)), (380, 70))
        sy = 110
        for i in range(3):
            meta = saves[i] if saves and i < len(saves) else None
            if meta:
                fecha = meta.get('fecha', 'sin fecha')
                existe = meta.get('_existe_en_disco', None)
                estado_fisico = "OK" if existe else "No existe"
                texto = f"{i+1}) {fecha} [{estado_fisico}]"
            else:
                texto = f"{i+1}) Vac√≠o"
            pantalla.blit(fuente.render(texto, True, (180, 180, 180)), (380, sy))
            sy += 28

        pygame.display.flip()
        clock.tick(30)
# ...existing code...
if __name__ == '__main__':
    controlador_global = Controlador()

    opcion, opcion_slot = menu_inicial(controlador_global)

    escenario = None
    jugador = None

    if opcion == 'l':
        index = controlador_global.listar_saves()
        most_recent = None
        recent_slot = None
        for i, meta in enumerate(index):
            if meta and meta.get('fecha'):
                if most_recent is None or meta['fecha'] > most_recent:
                    most_recent = meta['fecha']
                    recent_slot = i
        if recent_slot is not None:
            esc, jug = controlador_global.rescatar_slot(recent_slot)
            if esc is not None and jug is not None:
                escenario = esc
                jugador = jug
                print(f"Partida cargada desde slot {recent_slot + 1}.")

    elif opcion == 'l_slot' and opcion_slot is not None:
        esc, jug = controlador_global.rescatar_slot(opcion_slot)
        if esc is not None and jug is not None:
            escenario = esc
            jugador = jug
            print(f"Partida cargada desde slot {opcion_slot + 1}.")

    if escenario is None:
        escenario = crear_escenario_predeterminado()

    if jugador is None:
        jugador = Jugador(posicion_x=24, posicion_y=24)
        escenario.agregar_personaje(jugador)
    else:
        if jugador not in escenario.personajes:
            escenario.agregar_personaje(jugador)

    # Ahora S√ç crear la Vista (sin par√°metros en __init__)
    vista = Vista(escenario, jugador)